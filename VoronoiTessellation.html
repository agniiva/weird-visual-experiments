<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYSTEM // VORONOI_OPTIMIZER</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #050505;
            overflow: hidden;
            font-family: 'Space Mono', 'Courier New', monospace;
        }
        canvas {
            display: block;
        }

        /* --- INDUSTRIAL HUD LAYER --- */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            padding: 2rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
            mix-blend-mode: difference;
        }

        .header {
            border-top: 2px solid #FF3B00;
            padding-top: 10px;
            display: flex;
            justify-content: space-between;
            color: #FF3B00;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .footer {
            border-bottom: 2px solid #FF3B00;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            color: #888;
            font-size: 10px;
        }

        .data-block {
            text-align: right;
        }

        .scanline {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 3px;
            pointer-events: none;
            z-index: 20;
            opacity: 0.5;
        }

        .blinker { animation: blink 1s step-end infinite; }
        @keyframes blink { 50% { opacity: 0; } }

    </style>
</head>
<body>

<div class="scanline"></div>

<div class="ui-layer">
    <div class="header">
        <div>/// VORONOI_TESSELLATION</div>
        <div>OPTIMIZATION: <span class="blinker">ACTIVE</span></div>
    </div>
    
    <!-- Center floating label -->
    <div style="position: absolute; top: 50%; left: 2rem; transform: translateY(-50%); color: #FF3B00; writing-mode: vertical-rl; font-size: 10px; opacity: 0.7;">
        TERRITORY_MAPPING // DYNAMIC
    </div>

    <div class="footer">
        <div>
            LOGISTICS_NODES: <span id="node-count">30</span><br>
            GRID_LATENCY: 0.01ms
        </div>
        <div class="data-block">
            COORDINATES: <span id="coords">0,0</span><br>
            SECTOR_REMAP: AUTO
        </div>
    </div>
</div>

<canvas id="glcanvas"></canvas>

<!-- VERTEX SHADER: Standard Passthrough -->
<script id="vert-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
</script>

<!-- FRAGMENT SHADER: The Voronoi Logic -->
<script id="frag-shader" type="x-shader/x-fragment">
    precision highp float;

    uniform vec2 u_resolution;
    uniform float u_time;
    uniform vec2 u_mouse;
    
    // We pass the node positions as an array
    // We support up to 40 nodes for this demo
    uniform vec2 u_points[40];

    // Industrial Color Palette
    vec3 color_bg = vec3(0.02, 0.02, 0.02); // Void
    vec3 color_border = vec3(1.0, 0.23, 0.0); // Safety Orange
    vec3 color_cell = vec3(0.1, 0.1, 0.12); // Dark Steel

    void main() {
        vec2 st = gl_FragCoord.xy / u_resolution.xy;
        st.x *= u_resolution.x / u_resolution.y; // Aspect ratio correction

        // 1. DISTANCE FIELD CALCULATION
        // For every pixel, find the closest and 2nd closest point
        
        float m_dist = 1.0;  // Minimum distance
        float m_dist2 = 1.0; // Second minimum distance
        int closest_index = 0;

        for (int i = 0; i < 40; i++) {
            vec2 point = u_points[i];
            // Adjust point aspect ratio to match st
            point.x *= u_resolution.x / u_resolution.y;
            
            float dist = distance(st, point);

            if (dist < m_dist) {
                m_dist2 = m_dist;
                m_dist = dist;
                closest_index = i;
            } else if (dist < m_dist2) {
                m_dist2 = dist;
            }
        }

        // 2. MOUSE INTERACTION
        // Treat mouse as a super-node
        vec2 mouse_st = u_mouse / u_resolution.xy;
        mouse_st.x *= u_resolution.x / u_resolution.y;
        float mouse_dist = distance(st, mouse_st);
        
        if (mouse_dist < m_dist) {
            m_dist2 = m_dist;
            m_dist = mouse_dist;
        } else if (mouse_dist < m_dist2) {
            m_dist2 = mouse_dist;
        }

        // 3. VISUALIZATION
        
        // Cell Intensity (Darker at edges, lighter at center)
        // We invert the distance so center is bright
        float intensity = exp(-m_dist * 3.0); 
        
        // Borders
        // The border exists where distance to closest == distance to 2nd closest
        float border = m_dist2 - m_dist;
        // Sharpen the border line using smoothstep
        float line = smoothstep(0.005, 0.0, border);

        // Node Center Dots
        float center_dot = 1.0 - smoothstep(0.0, 0.015, m_dist);

        // Mixing the colors
        vec3 color = mix(color_bg, color_cell, intensity * 0.5);
        color = mix(color, color_border, line); // Add orange lines
        color = mix(color, vec3(1.0), center_dot); // Add white dots

        // Add noise grain for industrial texture
        float noise = fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453);
        color += noise * 0.05;

        gl_FragColor = vec4(color, 1.0);
    }
</script>

<script>
    /**
     * SYSTEM: VORONOI DYNAMICS
     * WebGL Implementation
     */
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl");

    if (!gl) alert("WebGL not supported");

    // --- SHADER BOILERPLATE ---
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const program = gl.createProgram();
    const vertShader = createShader(gl, gl.VERTEX_SHADER, document.getElementById("vert-shader").text);
    const fragShader = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById("frag-shader").text);
    
    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    // Full screen quad buffer
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1, 1, -1, -1, 1,
        -1, 1, 1, -1, 1, 1
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    // --- UNIFORMS ---
    const uResolution = gl.getUniformLocation(program, "u_resolution");
    const uTime = gl.getUniformLocation(program, "u_time");
    const uMouse = gl.getUniformLocation(program, "u_mouse");
    const uPoints = gl.getUniformLocation(program, "u_points");

    // --- STATE ---
    const POINT_COUNT = 40;
    let points = [];
    let velocities = [];
    let width, height;
    let mouse = { x: 0, y: 0 };

    function initPoints() {
        points = [];
        velocities = [];
        for(let i=0; i<POINT_COUNT; i++) {
            // Normalized coordinates 0.0 to 1.0
            points.push(Math.random(), Math.random());
            // Slow drift velocity
            velocities.push((Math.random()-0.5)*0.002, (Math.random()-0.5)*0.002);
        }
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        gl.viewport(0, 0, width, height);
        gl.uniform2f(uResolution, width, height);
    }

    function updatePhysics() {
        for(let i=0; i<POINT_COUNT; i++) {
            let idx = i * 2;
            let x = points[idx];
            let y = points[idx+1];
            let vx = velocities[idx];
            let vy = velocities[idx+1];

            x += vx;
            y += vy;

            // Bounce off walls
            if (x < 0 || x > 1) velocities[idx] *= -1;
            if (y < 0 || y > 1) velocities[idx+1] *= -1;

            points[idx] = x;
            points[idx+1] = y;
        }
    }

    function loop(time) {
        updatePhysics();

        gl.uniform1f(uTime, time * 0.001);
        gl.uniform2f(uMouse, mouse.x, height - mouse.y); // Flip Y for WebGL
        gl.uniform2fv(uPoints, new Float32Array(points));

        gl.drawArrays(gl.TRIANGLES, 0, 6);
        
        // Update UI coords
        if(Math.random() > 0.9) {
            document.getElementById('coords').innerText = 
                `${mouse.x.toFixed(0)},${mouse.y.toFixed(0)}`;
        }

        requestAnimationFrame(loop);
    }

    // --- EVENTS ---
    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', e => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });

    // Start
    initPoints();
    resize();
    loop(0);

</script>
</body>
</html>