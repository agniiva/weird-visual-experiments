<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DATA_STREAM // FLOW_FIELD</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #080808; /* Deep Industrial Black */
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        /* Optional UI overlay for the industrial feel */
        .ui-layer {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            font-family: 'Courier New', Courier, monospace;
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>

<div class="ui-layer">
    <div>/// VECTOR_FIELD_ANALYSIS</div>
    <div>DENSITY: HIGH</div>
    <div>FLOW: LAMINAR</div>
</div>

<canvas id="canvas"></canvas>

<script>
    /**
     * SIMPLEX NOISE IMPLEMENTATION (Compact)
     * A fast, 3D noise algorithm to generate the "wind" directions.
     */
    const SimplexNoise = (function() {
        // Permutation table
        const p = new Uint8Array(256);
        for (let i = 0; i < 256; i++) p[i] = i;
        // Shuffle
        for (let i = 255; i > 0; i--) {
            const r = Math.floor(Math.random() * (i + 1));
            [p[i], p[r]] = [p[r], p[i]];
        }
        const perm = new Uint8Array(512);
        const permMod12 = new Uint8Array(512);
        for (let i = 0; i < 512; i++) {
            perm[i] = p[i & 255];
            permMod12[i] = perm[i] % 12;
        }

        const F3 = 1.0 / 3.0;
        const G3 = 1.0 / 6.0;
        const grad3 = new Float32Array([
            1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0,
            1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1,
            0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1
        ]);

        return {
            noise3D: function(xin, yin, zin) {
                let n0, n1, n2, n3;
                const s = (xin + yin + zin) * F3;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                const k = Math.floor(zin + s);
                const t = (i + j + k) * G3;
                const X0 = i - t;
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = xin - X0;
                const y0 = yin - Y0;
                const z0 = zin - Z0;
                
                let i1, j1, k1, i2, j2, k2;
                if (x0 >= y0) {
                    if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                    else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                    else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
                } else {
                    if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                    else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
                }

                const x1 = x0 - i1 + G3;
                const y1 = y0 - j1 + G3;
                const z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0 * G3;
                const y2 = y0 - j2 + 2.0 * G3;
                const z2 = z0 - k2 + 2.0 * G3;
                const x3 = x0 - 1.0 + 3.0 * G3;
                const y3 = y0 - 1.0 + 3.0 * G3;
                const z3 = z0 - 1.0 + 3.0 * G3;

                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;

                const gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
                const t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                if (t0 < 0) n0 = 0.0;
                else {
                    const t0_sq = t0 * t0;
                    n0 = t0_sq * t0_sq * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
                }

                const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
                const t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                if (t1 < 0) n1 = 0.0;
                else {
                    const t1_sq = t1 * t1;
                    n1 = t1_sq * t1_sq * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
                }

                const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
                const t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                if (t2 < 0) n2 = 0.0;
                else {
                    const t2_sq = t2 * t2;
                    n2 = t2_sq * t2_sq * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
                }

                const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
                const t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                if (t3 < 0) n3 = 0.0;
                else {
                    const t3_sq = t3 * t3;
                    n3 = t3_sq * t3_sq * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
                }

                return 32.0 * (n0 + n1 + n2 + n3);
            }
        };
    })();

    /**
     * SYSTEM CONFIGURATION
     */
    const CONFIG = {
        particleCount: 4000,      // Density of the stream
        noiseScale: 0.002,        // Zoom level of the flow (lower = smoother curves)
        timeScale: 0.0001,        // Speed of the field evolution (wind change)
        particleSpeed: 2,         // How fast particles move
        fadeOpacity: 0.03,        // Trail length (lower = longer trails)
        color: '#FFFFFF'          // Particle color
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    let particles = [];
    let zOff = 0; // Time dimension

    class Particle {
        constructor() {
            this.reset();
        }

        reset() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.life = Math.random() * 100 + 50; // Random lifespan to prevent clumping
            
            // Previous position for drawing lines
            this.px = this.x;
            this.py = this.y;
        }

        update() {
            // Calculate flow direction based on Noise
            // We map the noise value (-1 to 1) to an angle (0 to 2*PI)
            const angle = SimplexNoise.noise3D(this.x * CONFIG.noiseScale, this.y * CONFIG.noiseScale, zOff) * Math.PI * 4;
            
            // Calculate velocity vector
            this.vx = Math.cos(angle) * CONFIG.particleSpeed;
            this.vy = Math.sin(angle) * CONFIG.particleSpeed;

            // Update position
            this.px = this.x;
            this.py = this.y;
            this.x += this.vx;
            this.y += this.vy;
            this.life--;

            // Boundary check & Life check
            if (this.x < 0 || this.x > width || this.y < 0 || this.y > height || this.life <= 0) {
                this.reset();
            }
        }

        draw() {
            ctx.beginPath();
            ctx.moveTo(this.px, this.py);
            ctx.lineTo(this.x, this.y);
            ctx.stroke();
        }
    }

    function init() {
        resize();
        particles = [];
        for(let i = 0; i < CONFIG.particleCount; i++) {
            particles.push(new Particle());
        }
        
        // Initial clear
        ctx.fillStyle = '#080808';
        ctx.fillRect(0, 0, width, height);
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        // Re-apply styles after resize
        ctx.fillStyle = '#080808';
        ctx.fillRect(0, 0, width, height);
    }

    function animate() {
        // 1. FADE EFFECT (Creates the trails)
        // Instead of clearing the screen, we draw a semi-transparent rectangle
        ctx.fillStyle = `rgba(8, 8, 8, ${CONFIG.fadeOpacity})`;
        ctx.fillRect(0, 0, width, height);

        // 2. DRAW PARTICLES
        ctx.strokeStyle = CONFIG.color;
        ctx.lineWidth = 0.8; // Very thin, elegant lines
        ctx.lineCap = 'round';

        for (let p of particles) {
            p.update();
            p.draw();
        }

        // 3. EVOLVE FIELD
        zOff += CONFIG.timeScale;

        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', init);
    init();
    animate();

    // Interactive: Click to scramble noise briefly
    canvas.addEventListener('mousedown', () => {
        zOff += 10; // Huge jump in time dimension
    });

</script>
</body>
</html>